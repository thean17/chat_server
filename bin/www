#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('socket-io-chat:server');
var http = require('http');
var connectDatabase = require('../database').default;
var { MessageType, default: Message } = require('../database/model/message');
const { default: Player } = require('../database/model/user');
const { default: Room } = require('../database/model/room');
const { default: RoomMember } = require('../database/model/roomMember');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

const io = require('socket.io')(server, {
	cors: {
		origin: '*',
	},
});

const users = {};
const groups = {};

const getSocketIdByUsername = (username) =>
	Object.keys(users).find((key) => users[key].username === username);

const getUsernameBySocketId = (socketId) => users[socketId].username;

const getGroups = () =>
	Object.keys(groups).map((key) =>
		Object.assign({}, groups[key], { name: key })
	);

const isGroupParticipant = (groupName, socketId) =>
	groups[groupName] && groups[groupName].participants[socketId];

/**
 *
 * @param {import('socket.io').Socket} socket
 */
const handleConnection = (socket) => {
	users[socket.id] = { username: socket.id, connectedAt: new Date() };

	socket.on('join_room', async (id) => {
		const room = await RoomMember.findOne({
			roomId: id,
			playerId: socket.handshake.headers.id,
		});

		if (room) {
			socket.join(room.roomId);

			socket.emit('join_room', room.roomId);
		} else {
			socket.emit('join_room', null);
		}
	});

	socket.on('send_message_to_room', (id, message, type = MessageType.Text) => {
		if (socket.rooms.has(id)) {
			Player.findById(socket.handshake.headers.id).then((player) => {
				return Message.create({
					playerId: player._id.toString(),
					playerName: player.playerName,
					roomId: id,
					type,
					content: message,
					createdBy: player.playerId,
				});
			});

			socket.to(id).emit('receive_message_from_room', message, type);
		}
	});

	socket.on('disconnect', async () => {
		delete users[socket.id];

		// if (socket.roomId) {
		// 	const matchingSockets = await io.in(socket.roomId).allSockets();
		// 	const isDisconnected = matchingSockets.size === 0;
		// 	if (isDisconnected) {
		// 		// notify other users
		// 		socket.broadcast.emit('user disconnected', socket.userID);
		// 		// update the connection status of the session
		// 		sessionStore.saveSession(socket.sessionID, {
		// 			userID: socket.userID,
		// 			username: socket.username,
		// 			connected: false,
		// 		});
		// 	}
		// }

		io.emit('get_active_users', Object.values(users));
	});

	socket.on('set_username', (username, func) => {
		if (Object.values(users).find((user) => user.username === username)) {
			if (typeof func === 'function') return func('username_exists');

			return;
		}

		users[socket.id].username = username;

		if (typeof func === 'function') func();

		io.emit('get_active_users', Object.values(users));
	});

	socket.on('get_groups', () => {
		console.log('get_groups: ', getGroups());
		socket.emit('set_groups', getGroups());
	});
	socket.on('create_group', (groupName) => {
		groups[groupName] = {
			createdBy: users[socket.id].username,
			participants: {},
		};

		console.log(groups);

		io.emit('set_groups', getGroups());
	});
	socket.on('join_group', (groupName) => {
		if (groups[groupName]) {
			const joined = isGroupParticipant(groupName, socket.id);

			console.log('join_group: ', joined);
			if (!joined) {
				groups[groupName].participants[socket.id] = users[socket.id];

				socket.join(groupName);
				socket.emit('joined_group', groupName);
			}
		}
	});
	socket.on('send_group_message', (groupName, message) => {
		console.log('send_group_message', groupName, groups[groupName]);
		if (isGroupParticipant(groupName, socket.id)) {
			io.to(groupName).emit(
				'receive_group_message#' + groupName,
				users[socket.id].username,
				message
			);
		} else {
			console.log('not group participant');
		}
	});
	socket.on('set_typing', (groupName) => {
		if (isGroupParticipant(groupName, socket.id)) {
			socket
				.to(groupName)
				.emit('is_typing#' + groupName, getUsernameBySocketId(socket.id));
		}
	});
	socket.on('unset_typing', (groupName) => {
		if (isGroupParticipant(groupName, socket.id)) {
			io.to(groupName).emit('is_typing#' + groupName, null);
		}
	});

	socket.on('message', (to, message, type) => {
		io.to(getSocketIdByUsername(to)).emit(
			'message',
			users[socket.id].username,
			message,
			type
		);
	});

	socket.broadcast.emit('get_active_users', Object.values(users));
	socket.on('get_active_users', () => {
		socket.emit('get_active_users', Object.values(users));
	});

	socket.on('my_ping', () => {
		console.log('ping');
		socket.emit('my_pong');
	});

	socket.emit('message', 'WELCOME');
};

io.on('connection', handleConnection);

io.on('disconnect', (reason) => {
	console.log('disconnected: ', reason);

	delete users[socket.id];
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges');
			process.exit(1);
			break;
		case 'EADDRINUSE':
			console.error(bind + ' is already in use');
			process.exit(1);
			break;
		default:
			throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

async function onListening() {
	var addr = server.address();
	var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;

	await connectDatabase();

	debug('Listening on ' + bind);
}
